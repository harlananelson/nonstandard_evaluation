---
title: "Nonstandard Evaluation"
output: html_notebook
---

# Abstract
This is a review of non-standard evaluation using the references listed below. Exercises are  included. The goal is scafolded explaination and learning.

## References
https://edwinth.github.io/blog/nse/

http://dplyr.tidyverse.org/articles/programming.html

## Vocabulary
The term expression is used often in NSE.  It is a concept, not a class or type,
but it covers four R classes.
It is different from the return value of *expression* generated by ```typeof()``` or ```class()```.
The expression concept includes the four classes: name, call, constant and pairlists. 
The expression is a construct that is created in one statement,
then evaluated in another statment.

## The Purpose of Nonstandard Evaluation
NSE separates the creation of
an expression and the evaluation of the expression.  Instead of the evaluation
taking place at an uncontrolled time, it is evaluated deliberately in the function in
the environment as specified.  The same expression can be evaluated many
times in many different environments.  The expression can even be modified
before its evaluation. 
The eval statement or some other mechanism is used to evaluate the expression
in the desired environment.
Nonstandard evaluation (NSE) is a tool most useful in functions.  
In relation to functions, it is a method to take the value or expression
sent to a function through the function parameter and capture it as an
expression.  With the parameter value passed to the function captured as an
expression, it can then be evaluated in the environment of choice.  
Many times this environment is a data.table or list.


##Name
This is one of the four classes encompassed in the concept of NSE.
In standard evaluation, names return their values. 
In this example of an expression, ```x``` is a name that returns its numeric value.
```{r}
x <-1
class(x)
x
```

In the examples below, an expression of class name is used.  When evaluation
is done, the name referenced by the expression is looked up in the 
environment and the value of that name is returned.  Three ways of 
creating the name are shown. Also illustrated is what happens when
an environment other than the default global or parent evironment is used.
It is also clear that the class of the expression is *name*


```{r}
x<-3
x1 <- as.name('x')
typeof(x1)
class(x1)
eval(x1)
eval(x1,list(x=5))

x2 <- as.symbol('x')
typeof(x2)
class(x2)
eval(x2)
eval(x1,list(x=5))

x3 <- quote(x)
typeof(x3)
class(x3)
eval(x3)
eval(x1,list(x=5))
```
Here is the same concept as applied to functions.
Look at what happens when ```quote``` is used to capture the
value of the function parameter as an expression.  
It doesn't work has needed.  The quote captures the "c" not the "x".
```{r}
x<-3
f1<-function(c){
  x<-4
  cq<-quote(c)
  print(typeof(cq))
  print(class(cq))
  print(cq)
  print(eval(cq))
  print(eval(cq,list(x=6,c=1)))
}
print("x=3")
f1(x)
```
The ```quote``` function does not work as intended in a function with the 
function parameter, instead the ```substitute``` function is used.

```{r}
f2<-function(c){
  x<-7
  cs<-substitute(c)
  print(typeof(cs))
  print(class(cs))
  print(cs)
  print(eval(cs))
  print(eval(cs,list(x=5)))
}
f2(x)
```

Here is a short example of extracting a column from a data frame. 
This will be used in the next example
```{r}
d <- data.frame(x=c(1:5))
d
d[,'x'] # As a data framme: extract the column called x as an atomic vector 
d[['x']] # As a list: Extract the column called x as an atomic vector 
d['x'] # As a list: Extract the column called x as a one column data.frame
```
The expression sent to the function is captured as a name and then
used to index the data.frame using list indexing.  
The expression contained in cs is a *name* and that name ```x```
is the name of a column of the data.frame.  The name expression
is evaluated in the environment of the data.frame.
```{r}
f3<-function(c){
  d <- data.frame(x=c(1:5))
  cs<-substitute(c)
  d[[cs]] # As a list: Extract the column called x as a atomic vector 
}
f3(x)
```
Using non-standard evaluation in this case is actually pointless
because it would be much more simple to just pass the name of the 
column desired.
```{r}
f4<-function(c){
  d <- data.frame(x=c(1:5))
  d[[c]] # As a list: Extract the column called x as a atomic vector 
}
f4('x')
```



##call
Another type of an expression is a call.
```{r}
x<-3
y<-4
y1<-quote(x+y^2)
typeof(y1)
class(y1)
eval(y1)
```
The call is evaluated based on the environment used.
```{r}
x<-5
y<-8
typeof(y1)
class(y1)
eval(y1)
```
```{r}
x<-3
y<-2
y1<-quote(x+y^2)
eval(y1)
deparse(y1)

typeof(y2)
class(y2)
eval(y2)
eval(eval(y2))

```
